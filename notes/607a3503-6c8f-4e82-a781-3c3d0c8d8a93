:PROPERTIES:
:ID:       607a3503-6c8f-4e82-a781-3c3d0c8d8a93
:END:
#+title: 数据结构与算法
#+filetags: DS

* 根据排序过程确定排序算法
** 快速排序
选取首位 pivot

- 4 7 6 5 3 2 8 1
  - 1 2 3 5 6 8 7
- 3 1 2 4 5 6 8 7

** 归并排序
分割--归并
- 4 2 5 3 1 6
- 4 2 5   3 1 6
- 4 2   5   3 1  6
- 4   2   5 3   1  6
- 2 4   5   1 3  6
- 2 4 5  1 3 6
- 1 2 3 4 5 6

** 冒泡排序
- 61 17 29 22 34 60 72 21 50 1 62 
- 17 29 22 34 60 61 21 50 1 62 72 
- 17 22 29 34 60 21 50 1 61 62 72 
- 17 22 29 34 21 50 1 60 61 62 72 
- 17 22 29 21 34 1 50 60 61 62 72 
- 17 22 21 29 1 34 50 60 61 62 72 
- 17 21 22 1 29 34 50 60 61 62 72 
- 17 21 1 22 29 34 50 60 61 62 72 
- 17 1 21 22 29 34 50 60 61 62 72 
- 1 17 21 22 29 34 50 60 61 62 72 
- 1 17 21 22 29 34 50 60 61 62 72 

** 希尔排序

* 根据遍历结果确定二叉树 
求解过程： 
 1. 先序序列第一个结点一定是二叉树的根节点 。后序序列最后一个节点一定是二叉树的根节点 
 2. 根节点在中序序列中必然将中序序列分割为两个子序列，
    前一个序列为根节点的左子树的中序序列，
    后一个序列为根节点的右子树的中序序列。 
 3. 递归使用以上两条法则，直到序列只剩下一个结点。

* 算法思路
[[id:1172ba6a-30c8-4d31-9051-f317896c4b9e][动态规划]]

** 栈
[[id:d7c6e588-c653-4d58-8b6a-807ef7edf08a][逆波兰表达式]]
